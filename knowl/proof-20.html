<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<article class="hiddenproof"><h3 class="heading"><span class="type">Proof</span></h3>
<div class="para">It is clear that <span class="process-math">\(\prufer(\bfT)\)</span> takes an <span class="process-math">\(n\)</span>-vertex labeled tree with labels from <span class="process-math">\([n]\)</span> and returns a string of length <span class="process-math">\(n-2\)</span> whose symbols are elements of <span class="process-math">\([n]\text{.}\)</span> What we have yet to do is determine a way to take such a string and construct an <span class="process-math">\(n\)</span>-vertex labeled tree from it. If we can find such a construction, we will have a bijection between the set <span class="process-math">\(\mathcal{T}_n\)</span> of labeled trees on <span class="process-math">\(n\)</span> vertices and the set of strings of length <span class="process-math">\(n-2\)</span> whose symbols come from <span class="process-math">\([n]\text{,}\)</span> which will imply that <span class="process-math">\(T_n=n^{n-2}\text{.}\)</span>
</div> <div class="para">First, let’s look at how <span class="process-math">\(\prufer(\bfT)\)</span> behaves. What numbers actually appear in the Prüfer code? The numbers that appear in the Prüfer code are the labels of the <em class="emphasis">nonleaf</em> vertices of <span class="process-math">\(\bfT\text{.}\)</span> The label of a leaf simply cannot appear, since we always record the label of the <em class="emphasis">neighbor</em> of the leaf we are deleting, and the only way we would delete the neighbor of a leaf is if that neighbor were also a leaf, which can only happen if <span class="process-math">\(\bfT\cong\bfK_2\text{,}\)</span> in which case <span class="process-math">\(\prufer(\bfT)\)</span> simply returns the empty string. Thus if <span class="process-math">\(I\subset [n]\)</span> is the set of symbols that appear in <span class="process-math">\(\prufer(\bfT)\text{,}\)</span> the labels of the leaves of <span class="process-math">\(\bfT\)</span> are precisely the elements of <span class="process-math">\([n]-I\text{.}\)</span>
</div> <div class="para">With the knowledge of which labels belong to the leaves of <span class="process-math">\(\bfT\)</span> in hand, we are ready to use induction to complete the proof. Our goal is to show that if given a string <span class="process-math">\(\bfs=s_1s_2\cdots s_{n-2}\)</span> whose symbols come from a set <span class="process-math">\(S\)</span> of <span class="process-math">\(n\)</span> elements, there is a unique tree <span class="process-math">\(\bfT\)</span> with <span class="process-math">\(\prufer(\bfT) = \bfs\text{.}\)</span> If <span class="process-math">\(n=2\text{,}\)</span> the only such string is the empty string, so <span class="process-math">\(1\)</span> and <span class="process-math">\(2\)</span> both label leaves and we can construct only <span class="process-math">\(\bfK_2\text{.}\)</span> Now suppose we have the result for some <span class="process-math">\(m\geq 2\text{,}\)</span> and we try to prove it for <span class="process-math">\(m+1\text{.}\)</span> We have a string <span class="process-math">\(\bfs = s_1s_2\cdots s_{m-1}\)</span> with symbols from <span class="process-math">\([m+1]\text{.}\)</span> Let <span class="process-math">\(I\)</span> be the set of symbols appearing in <span class="process-math">\(\bfs\)</span> and let <span class="process-math">\(k\)</span> be the least element of <span class="process-math">\([m+1]-I\text{.}\)</span> By the previous paragraph, we know that <span class="process-math">\(k\)</span> is the label of a leaf of <span class="process-math">\(\bfT\)</span> and that its unique neighbor is the vertex labeled <span class="process-math">\(s_1\text{.}\)</span> The string <span class="process-math">\(\bfs'=s_2s_3\cdots s_{m-1}\)</span> has length <span class="process-math">\(m-2\)</span> and since <span class="process-math">\(k\)</span> does not appear in <span class="process-math">\(\bfs\text{,}\)</span> its symbols come from <span class="process-math">\(S=[m+1]-\{k\}\text{,}\)</span> which has size <span class="process-math">\(m\text{.}\)</span> Thus, by induction, there is a unique tree <span class="process-math">\(\bfT'\)</span> whose Prüfer code is <span class="process-math">\(\bfs'\text{.}\)</span> We form <span class="process-math">\(\bfT\)</span> from <span class="process-math">\(\bfT'\)</span> by attaching a leaf with label <span class="process-math">\(k\)</span> to the vertex of <span class="process-math">\(\bfT'\)</span> with label <span class="process-math">\(s_1\)</span> and have a tree of the desired type.</div></article><span class="incontext"><a href="s_graphs_counting-trees.html#proof-20" class="internal">in-context</a></span>
</body>
</html>
