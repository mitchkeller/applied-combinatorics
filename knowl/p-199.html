<!DOCTYPE html>
<html lang="en-US" dir="ltr">
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex, nofollow">
</head>
<body class="ignore-math">
<h4 class="heading"><span class="type">Paragraph</span></h4>
<div class="para">Consider a path <span class="process-math">\(s\in\cgB\text{.}\)</span> Then there is a least integer <span class="process-math">\(i\)</span> so that <span class="process-math">\(s\)</span> has more <span class="process-math">\(V\)</span>’s than <span class="process-math">\(H\)</span>’s in the first <span class="process-math">\(i\)</span> positions. By the minimality of <span class="process-math">\(i\text{,}\)</span> it is easy to see that <span class="process-math">\(i\)</span> must be odd (otherwise, we can back up a step), and if we set <span class="process-math">\(i=2j+1\text{,}\)</span> then in the first <span class="process-math">\(2j+1\)</span> positions of <span class="process-math">\(s\text{,}\)</span> there are exactly <span class="process-math">\(j\)</span> <span class="process-math">\(H\)</span>’s and <span class="process-math">\(j+1\)</span> <span class="process-math">\(V\)</span>’s. The remaining <span class="process-math">\(2n-2j-1\)</span> positions (the “tail of <span class="process-math">\(s\)</span>”) have <span class="process-math">\(n-j\)</span> <span class="process-math">\(H\)</span>’s and <span class="process-math">\(n-j-1\)</span> <span class="process-math">\(V\)</span>’s. We now transform <span class="process-math">\(s\)</span> to a new string <span class="process-math">\(s'\)</span> by replacing the <span class="process-math">\(H\)</span>’s in the tail of <span class="process-math">\(s\)</span> by <span class="process-math">\(V\)</span>’s and the <span class="process-math">\(V\)</span>’s in the tail of <span class="process-math">\(s\)</span> by <span class="process-math">\(H\)</span>’s and leaving the initial <span class="process-math">\(2j+1\)</span> positions unchanged. For example, see <a href="" class="xref" data-knowl="./knowl/flippath.html" title="Figure 2.29">Figure 2.29</a>, where the path <span class="process-math">\(s\)</span> is shown solid and <span class="process-math">\(s'\)</span> agrees with <span class="process-math">\(s\)</span> until it crosses the line <span class="process-math">\(y=x\)</span> and then is the dashed path. Then <span class="process-math">\(s'\)</span> is a string of length <span class="process-math">\(2n\)</span> having <span class="process-math">\((n-j)+(j+1) = n+1\)</span> <span class="process-math">\(V\)</span>’s and <span class="process-math">\((n-j-1)+j=n-1\)</span> <span class="process-math">\(H\)</span>’s, so <span class="process-math">\(s'\)</span> is a lattice path from <span class="process-math">\((0,0)\)</span> to <span class="process-math">\((n-1,n+1)\text{.}\)</span> Note that there are <span class="process-math">\(\binom{2n}{n-1}\)</span> such lattice paths.</div>
<span class="incontext"><a href="s_strings_bin-coeff.html#p-199" class="internal">in-context</a></span>
</body>
</html>
